# Generic configuration for Hurd compilation

# Directory makefiles should set the variable makemode to either
# `server' if they compile and install a single program for /hurd
# `utility' if they compile and install a single program for /bin
# `servers' if they compile and install multiple programs for /hurd
# `utilities' if they compile and install multiple programs for /bin
# `library' if they compile and install a library
# `misc' if they do none of those

# Every makefile should define
# SRCS (all actual source code)
# LCLHDRS (all source headers in this directory [NOT MiG created])
# REMHDRS (all Hurd headers in other directories [NOT .defs files])

# Types `server', `utility', and `library' should define
# OBJS (all .o files used to produce the target).

# Types `server', and `utility', should define
# HURDLIBS (all Hurd libraries used, omitting the dirname and the .a.)

# Types `server' and `utility' should define
# OTHERLIBS (all other libraries used)
# target (the name of the program built)

# Types `servers' and `utilities' should define
# targets (the names of all the programs built)
# foo-HURDLIBS (for each target FOO)
# special-targets (targets which should not be built the normal way
# and have their own rules)

# Type `library' should define
# libname (the name of the library, without .a.)
# installhdrs (header files that should be installed in /include)


# Put this first so it's the default
all:


# Root of installation and source directories
prefix := /home/gd4/hurdinst
exec_prefix := $(prefix)
srcdir := /home/gd4/gnu/hurd

# Where to install things
hurddir := $(exec_prefix)/hurd
bindir := $(exec_prefix)/bin
libdir := $(exec_prefix)/lib
infodir := $(prefix)/info
includedir := $(prefix)/include

# END CONFIGURATION AREA


# Decode makemode:


ifeq ($(makemode),server)
 doinst := one
 installationdir := $(hurddir)
 clean := yes
 cleantarg := $(target)
endif

ifeq ($(makemode),utility)
 doinst := one
 installationdir := $(bindir)
 clean := yes
 cleantarg := $(target)
endif

ifeq ($(makemode),servers)
 doinst := many
 installationdir := $(hurddir)
 clean := yes
 cleantarg := $(targets)
endif

ifeq ($(makemode),utilities)
 doinst := many
 installationdir := $(bindir)
 clean := yes
 cleantarg := $(targets)
endif

ifeq ($(makemode),library)
 clean := yes
 cleantarg := $(libname).a $(libname).so
endif



# Finding binaries
include $(srcdir)/Maketools

# Flags for compilation.  
# It is important to have this inclusion first; that picks up our 
# library header files locally rather than from installed copies.
# Append to any value set by the specific Makefile.
CPPFLAGS += -I$(srcdir)
CFLAGS += -Wall -g


# Standard targets

# Installation
ifeq ($(doinst),one)
all: $(target)
install: $(installationdir)/$(target)
$(installationdir)/$(target): $(target)
	$(INSTALL_BIN) $< $@
endif

ifeq ($(doinst),many)
all: $(targets)
install: $(addprefix $(installationdir)/,$(targets))
$(addprefix $(installationdir)/,$(targets)): %(installationdir)/%: %
	$(INSTALL_BIN) $< $@
endif

ifeq ($(makemode),library)
all: $(libname).a $(libname).so
install: $(libdir)/$(libname).a $(libdir)/$(libname).so $(addprefix $(includedir)/hurd/,$(installhdrs))

$(libdir)/$(libname).a: $(libname).a
	$(INSTALL_DATA) $(libname).a $(libdir)/$(libname).a
	$(RANLIB) $(libdir)/$(libname).a
$(libdir)/$(libname).so: $(libname).so
	$(INSTALL_DATA) $(libname).so $(libdir)/$(libname).so

$(addprefix $(includedir)/hurd/,$(installhdrs)): $(includedir)/hurd/%: %
	$(INSTALL_DATA) $< $@

endif
# Provide default.
install:

# Always, until bugs are fixed.
LDFLAGS += -static

ifeq ($(doinst),many)
HURDLIBS=$(foreach targ,$(targets),$($(targ)-HURDLIBS))
endif

# We use recursively expanded variables that reference the automatic
# variables in the link rules.  For now, you have to say -static
# in $(LDFLAGS); it cannot be in a per-target LDFLAGS.
#ifeq ($(doinst),many)
#  HURDLIBS-libs = $(foreach lib,$($@-HURDLIBS), -L../$(lib)  \
#			$(patsubst lib%,-l%,$(lib)))
#else
#  HURDLIBS-libs = $(foreach lib,$(HURDLIBS), -L../$(lib)  \
#			$(patsubst lib%,-l%,$(lib)))
#endif
HURDLIBS-libs = $(HURDLIBS-files)

# This variable is used for the default library-building rule
# and for dependencies.  For the former, this is always adequate.
# But for the latter, there is no automatic way, so our includer
# will have to construct the dependency list by hand.
ifeq ($(filter-out -static,$(LDFLAGS)),$(LDFLAGS))
  HURDLIBS-files = $(foreach lib,$(HURDLIBS), ../$(lib)/$(lib).so)
else
  HURDLIBS-files = $(foreach lib,$(HURDLIBS), ../$(lib)/$(lib).a)
endif

# Building the target
ifeq ($(doinst),one)
$(target): $(OBJS) $(HURDLIBS-files) $(OTHERLIBS)
	$(CC) $(CFLAGS) $(LDFLAGS) -o $(target) '-Wl,-(' \
	$(OBJS) $(HURDLIBS-libs) $(OTHERLIBS) $(libc) '-Wl,-)'
endif

ifeq ($(doinst),many)
$(filter-out $(special-targets),$(targets)): %:
	$(CC) $(CFLAGS) $($@-CFLAGS) $(LDFLAGS) $($@-LDFLAGS) \
	-o $@ '-Wl,-(' $(filter-out $(HURDLIBS-files),$+) \
	$(HURDLIBS-libs) $($@-OTHERLIBS) $(libc) '-Wl,-)'
endif

ifeq ($(makemode),library)
$(libname).a: $(OBJS)
	rm -f $(libname).a
	$(AR) r $@ $^
	$(RANLIB) $@

$(libname).so: $(patsubst %.o,%_pic.o,$(OBJS))
	$(CC) -shared $(CFLAGS) -o $(libname).so $+
endif

# Making a snapshot
distfiles = Makefile ChangeLog $(SRCS) $(LCLHDRS) $(DIST_FILES)
lndist: $(distfiles) $(srcdir)/hurd-snap/$(dir) FORCE
	ln $(distfiles) $(srcdir)/hurd-snap/$(dir)
 
ifeq ($(dir),.)
$(srcdir)/hurd-snap/$(dir):
else
$(srcdir)/hurd-snap/$(dir):
	mkdir $(srcdir)/hurd-snap/$(dir)
endif

# TAGS files
ifneq ($(dir),.)
TAGS: $(SRCS) $(LCLHDRS) $(REMHDRS) $(OTHERTAGS)
	etags -o $@ $(HURDLIBS:-i ../%/TAGS) $(SRCS) \
	      $(LCLHDRS) $(REMHDRS) $(OTHERTAGS)
endif


# Cleaning
ifeq ($(clean),yes)
clean:
	rm -f *.d *.*_d *.o *Server.c *User.c *_S.h *_U.h $(cleantarg)
ifneq ($(makemode),library)
relink:
	rm -f $(cleantarg)
endif
endif
clean:
relink:



# Subdependencies

# Building Hurd libraries
$(sort $(HURDLIBS-files)): FORCE
	$(MAKE) -C $(dir $@) $(notdir $@)


# Default rule to build PIC object files.
%_pic.o: %.c
	$(CC) -c $(CPPFLAGS) $(CFLAGS) -fPIC $< -o $@


# How to build RPC stubs

# User settable variables:
# 	MIGSFLAGS	   flags to CPP when building server stubs and headers
#	foo-MIGSFLAGS	   same, but only for interface `foo'
# 	MIGCOMSFLAGS	   flags to MiG when building server stubs and headers
#	foo-MIGCOMSFLAGS   same, but only for interface `foo'
# 	MIGUFLAGS	   flags to CPP when building user stubs and headers
#	foo-MIGUFLAGS	   same, but only for interface `foo'
# 	MIGCOMUFLAGS	   flags to MiG when building user stubs and headers
#	foo-MIGCOMUFLAGS   same, but only for interface `foo'
#	CPPFLAGS	   flags to CPP

# Implicit rules for building server and user stubs from mig .defs files.
%_S.h %Server.c: %.defs
	$(CPP) $(CPPFLAGS) $(MIGSFLAGS) $($*-MIGSFLAGS) -DSERVERPREFIX=S_ $< \
	| $(MIGCOM) $(MIGCOMSFLAGS) $($*-MIGCOMSFLAGS) \
		    -sheader $*_S.h -server $*Server.c \
		    -user /dev/null -header /dev/null
%_U.h %User.c: %.defs
	$(CPP) $(CPPFLAGS) $(MIGUFLAGS) $($*-MIGUFLAGS) $< \
	| $(MIGCOM) $(MIGCOMUFLAGS) $($*-MIGCOMUFLAGS) \
		    -user $*User.c -server /dev/null -header $*_U.h


# Where to find .defs files.
vpath %.defs $(srcdir)/hurd:$(crossheaders)/mach:$(crossheaders)/device

FORCE:


# How to build automatic dependencies

# For each file generated by MiG we need a .d file.
# These lines assume that every Makefile that uses a foo_S.h or foo_U.h file
# also mentions the associated fooServer.o or fooUser.o file.
include $(subst Server.o,.migs_d,$(filter %Server.o,$(OBJS))) /dev/null
include $(subst User.o,.migu_d,$(filter %User.o,$(OBJS))) /dev/null 
include $(subst Server.o,.migsh_d,$(filter %Server.o,$(OBJS))) /dev/null
include $(subst User.o,.miguh_d,$(filter %User.o,$(OBJS))) /dev/null

# For each .o file we need a .d file.
include $(subst .o,.d,$(OBJS)) /dev/null


# Here is how to build those dependency files

# Dependencies for fooServer.c files.
%.migs_d: %.defs
	(set -e; $(CPP) $(CPPFLAGS) $(MIGSFLAGS) $($*-MIGSFLAGS) \
		 -DSERVERPREFIX=S_ -M -MG $< | \
	sed -e 's/\.defs\.o:/Server\.c $@:/' > $@)

# Dependencies for fooUser.c files.
%.migu_d: %.defs
	(set -e; $(CPP) $(CPPFLAGS) $(MIGUFLAGS) $($*-MIGUFLAGS) \
		-M -MG $< | \
	sed -e 's/\.defs\.o:/User\.c $@:/' > $@)

# The associated .h files are build by the same CCP, so a simple massaging
# of the previous two will work.
%.migsh_d: %.migs_d
	sed -e 's/Server\.c/_S\.h/' -e 's/migs_d/migsh_d/' < $< > $@
%.miguh_d: %.migu_d
	sed -e 's/User\.c/_U\.h/' -e 's/migu_d/miguh_d/' < $< > $@

# Here is how to make .d files from .c files
%.d: %.c
	(set -e; $(CC) $(CFLAGS) $(CPPFLAGS) -M -MG $<  | \
	sed -e 's/$*\.o:/$*.o $@:/' > $@)

# Here is how to make .d files from .S files
%.d: %.S
	(set -e; $(CC) $(CFLAGS) $(CPPFLAGS) -M -MG $< | \
	sed -e 's/*\.o:/$*.o $@:/' > $@)
	
# .s files don't go through the preprocessor, so we do this
# This rule must come *after* the genuine ones above, so that
# make doesn't build a .s file and then make an empty dependency
# list.
%.d: %.s
	echo '$*.o: $*.s' > $*.d

