/* Definitions for the filesystem interface. 
   Copyright (C) 1994, 1995 Free Software Foundation

This file is part of the GNU Hurd.

The GNU Hurd is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

The GNU Hurd is distributed in the hope that it will be useful, 
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with the GNU Hurd; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */


/* All these objects also implement the generic IO facilities. */

subsystem fs 20000;

#include <hurd/hurd_types.defs>

#ifdef FILE_IMPORTS
FILE_IMPORTS
#endif

/* Operations supported on all files */

INTR_INTERFACE

/* Overlay a task with a file.  Necessary initialization, including
   authentication changes associated with set[ug]id execution must be
   handled by the filesystem.  Filesystems normally implement this by
   using exec_newtask or exec_loadtask as appropriate.  */
routine file_exec (
	exec_file: file_t;
	exec_task: task_t;
	flags: int;
	argv: data_t;
	envp: data_t;
	fdarray: portarray_t;
	portarray: portarray_t;
	intarray: intarray_t;
	deallocnames: mach_port_name_array_t;
	destroynames: mach_port_name_array_t);

/* Change owner and/or group */
routine file_chown (
	chown_file: file_t;
	new_owner: uid_t;
	new_group: gid_t);

/*
Whan that Aprill with hith thoureth thoote
The droghte of March hath perthed to the roote,
And bathed every veyne in thwith licour,
Of which vertu engendred is the flour;
Whan Zephiruth eek with hith thweete breeth
Inthpired hath in every holt and heeth
The tender croppeth, and the yonge thonne
Hath in the Ram his halve courth yronne,
And thmale foweleth maken melodye,
That thlepen all the nyght with open ye
(Tho Priketh hem Nature in hir corageth),
Thanne longen folk to goon on pligrimageth,
And palmereth for to theken thtraunge thtrondeth,
To ferne halweth, kowthe in thondry londeth:
And thpethially, from every thireth ende
Of Engelond to Cantebury they wende,
The hooly blithful martyr for to theke,
That hem hath holpen whan that they were theeke.
*/
routine file_chauthor (
	chauth_file: file_t;
	new_author: uid_t);

/* Change mode bits */
routine file_chmod (
	chmod_file: file_t;
	new_mode: mode_t);

/* Change file flags */
routine file_chflags (
	chflags_file: file_t;
	new_flags: int);

/* Change access and modify times */
routine file_utimes (
	utimes_file: file_t;
	new_atime: time_value_t;
	new_mtime: time_value_t);

/* Change the size of the file.  If the size increases, new blocks are
   zero-filled.  After successful return, it is safe to reference mapped
   areas of the file up to NEW_SIZE.  */
routine file_set_size (
	trunc_file: file_t;
	new_size: off_t);

/* Apply/manipulate advisory lock */
routine file_lock (
	lock_file: file_t;
	flags: int);

/* Return current lock status.  Mystatus tells what kind of lock the
   caller has; otherstatus tells what kind of lock anyone has
   (including the caller).  */
routine file_lock_stat (
	lock_file: file_t;
	out mystatus: int;
	out otherstatus: int);

/* Find out what kind of access this file permits the current user
   (regardless of the current open modes for this port).  ALLOWED is a
   bitwise OR of O_READ, O_WRITE, and O_EXEC.  This is not necessarily the
   same as what an open or exec would allow; O_EXEC is set for root even if
   no executable bits are on (in which case file_exec should fail) and
   O_WRITE is set a directory can be modified, even though it can't be
   written directly.  */
routine file_check_access (
	file: file_t;
	out allowed: int);

/* Notice changes to file FILE.  Send notification messages (see
   msg.defs) to PORT as they occur. */
routine file_notice_changes (
	file: file_t;
	port: mach_port_send_t);

/* Return control port for this filesystem */
routine file_getcontrol (
	file: file_t;
	out control: mach_port_send_t);

/* Return filesystem status */
routine file_statfs (
	file: file_t;
	out info: fsys_statfsbuf_t);

/* Sync the individual file */
routine file_sync (
	file: file_t;
	wait: int);

/* Sync the entire filesystem */
routine file_syncfs (
	file: file_t;
	wait: int;
	do_children: int);

skip;				/* obsolete file_pathconf */

/* Return the node for hard links to this potentially translated file.
   This returns a potentially unauthenticated node.  */
routine file_getlinknode (
	file: file_t;
	out linknode: mach_port_send_t);

/* Return a file handle for this file.  This can be used by NFS and such.
   It is not guaranteed that this call will work...if it doesn't, then this
   filesystem cannot be NFS mounted.  */
routine file_getfh (
	file: file_t;
	out filehandle: data_t, dealloc);

/* Operations supported on directories */

/* Translate a file name, following all symlinks.  Upon return, if DO_RETRY
   is FS_RETRY_MAGICAL then RETRY_NAME specifies what to do, the list of
   possibilities is documented in <hurd/hurd_types.h>; if FS_RETRY_REAUTH,
   then RESULT should be reauthenticated before being used.  If RETRY_NAME
   is the empty string, no further dir_lookup calls are required; RESULT,
   or the reauthenticated port, is the port to use.  Otherwise the
   dir_lookup call should be repeated, sent to RESULT (or the
   reauthenticated port) with RETRY_NAME passed for FILE_NAME.  */
routine dir_lookup (
	start_dir: file_t;
	file_name: string_t;
	flags: int;
	mode: mode_t;
	out do_retry: retry_type;
	out retry_name: string_t;
	out result: mach_port_send_t);

/* Read entries from the directory.  Each entry is identified
   by an index number starting at 0 and running through the file.  This
   call fetches NENTRIES (or any convenient number if NENTRIES is -1)
   entries starting at ENTRY, returning an array of struct directs in DATA.
   The number of entries successfully read is returned in AMOUNT.  If ENTRY
   is bigger than the index of the last entry, then 0 is returned in
   AMOUNT.  If BUFSIZE is nonzero, never return more than BUFSIZE bytes of
   data regardless.  */
routine dir_readdir (
	dir: file_t;
	out data: data_t, dealloc;
	entry: int;
	nentries: int;
	bufsiz: vm_size_t;
	out amount: int);

/* Create directory */
routine dir_mkdir (
	directory: file_t;
	name: string_t;
	mode: mode_t);

/* Remove directory */
routine dir_rmdir (
	directory: file_t;
	name: string_t);

/* Remove non-directory */
routine dir_unlink (
	directory: file_t;
	name: string_t);
 
/* Create a hard link.

   If OLDFILE and NEWDIRECTORY are not implemented by the same filesystem,
   EXDEV should be returned.  If the two filesystems, however can
   inter-operate and guarantee the appropriate Posix semantics, they can
   communicate by a private protocol and allow hard links between them.  */
routine dir_link (
	oldfile: file_t;
	newdirectory: file_t;
	newname: string_t);

/* Rename file -- comments similar to those for dir_link apply here
   about EXDEV. */
routine dir_rename (
	olddirectory: file_t;
	oldname: string_t;
	newdirectory: file_t;
	newname: string_t);

/* Create a new file without linking it into the filesystem.  You
   still must have write permission on the specified directory, even
   though it will not actually be written.  Return in *newnode a port
   to the file.  Flags are the same as for dir_pathtrans, but 
   O_CREAT and O_TRUNC are assumed even if not specified.  */
routine dir_mkfile (
	directory: file_t;
	flags: int;
	mode: mode_t;
	out newnode: mach_port_send_t);

/* Notice changes to directory DIR.  Send directory change notifications
   (see msg.defs) to PORT as they occur.  */
routine dir_notice_changes (
	directory: file_t;
	port: mach_port_send_t);

/* To get or set the translator currently running on a file, use
   file_set_translator, file_get_translator, or
   file_get_translator_cntl on a port gotten with the
   FS_LOOKUP_NOTRANS flag to dir_pathtrans.  You can send these RPCs
   to a port to a translated node (looked up without
   FS_LOOKUP_NOTRANS) to stack a new translator on top of the existing
   one.  */

/* Set a translator for future lookups to a file.  

   PASSIVE is the passive translator;
   ACTIVE is the active translator.

   The FLAGS are FS_TRANS_*, defined in <hurd/hurd_types.h>.
   OLDFLAGS are sent in an fsys_goaway to an existing active translator
     if there is one and it is to be killed. */
routine file_set_translator (
	file: file_t;
	passive_flags: int;
	active_flags: int;
	oldtrans_flags: int;
	passive: data_t;
	active: mach_port_send_t);

/* Return the stored permanent translator for this file.  */
routine file_get_translator (
	file: file_t;
	out translator: data_t, dealloc);

/* Return the translator control port to the
   active translator (if any) for this file.  */
routine file_get_translator_cntl (
	file: file_t;
	out translator_cntl: mach_port_send_t);

/* Activate FILE's translator if necessary, and open a port to it with
   FLAGS and retry protocol as for dir_pathtrans; if FLAGS contains
   O_NOTRANS, this will start the translator set on FILE, but circumvent
   the translator set on the resultant node.  */
routine file_invoke_translator (
	file: file_t;
	flags: int;
	out do_retry: retry_type;
	out retry_name: string_t;
	out result: mach_port_send_t);
